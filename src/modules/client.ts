import { ConfigSchema } from "../schema/config";
import { ResponseSchema, responseSchema } from "../schema/response";
import { Sort } from "../interfaces/sort";
import { Pagination } from "../interfaces/pagination";
import EventDispatcher from "./event-dispatcher";

export default class Client {
    private readonly _config: ConfigSchema;
    private readonly _eventDispatcher: EventDispatcher;

    private _sort: Sort | null = null;
    private _pagination: Pagination | null = null;
    private _search: string | null = null;

    constructor(config: ConfigSchema, eventDispatcher: EventDispatcher) {
        this._config = config;
        this._eventDispatcher = eventDispatcher;
    }

    /**
     * Refreshes data by triggering an AJAX request to the configured URL.
     * Handles the data response and dispatches appropriate events in the process,
     * including "before-data-fetch", "data-fetch", "after-data-fetch", and "data-fetch-error".
     */
    public refresh(): void {
        if (this._config.debug) console.info("Refreshing data..");

        // Generate request
        const fetchRequest: Request = this.generateRequest();

        // Dispatch event with fetch request to allow for custom handling
        this._eventDispatcher.dispatch("before-data-fetch", fetchRequest);

        fetch(fetchRequest).then(response => {
            if (response.ok) {
                response.json().then(data => {
                    const responseData: ResponseSchema = responseSchema.parse(data);

                    // Dispatch event
                    this._eventDispatcher.dispatch("data-fetch", responseData);
                    this._eventDispatcher.dispatch("after-data-fetch");
                }).catch(error => {
                    if (this._config.debug) console.error(error);
                    this._eventDispatcher.dispatch("data-fetch-error", { error: error });
                    this._eventDispatcher.dispatch("after-data-fetch");
                });
            }
        }).catch(error => {
            if (this._config.debug) console.error(error);
            this._eventDispatcher.dispatch("data-fetch-error", { error: error });
            this._eventDispatcher.dispatch("after-data-fetch");
        });
    }

    get sort(): Sort | null {
        return this._sort;
    }

    set sort(value: Sort | null) {
        this._sort = value;
    }

    get pagination(): Pagination | null {
        return this._pagination;
    }

    set pagination(value: Pagination | null) {
        this._pagination = value;
    }

    get search(): string | null {
        return this._search;
    }

    set search(value: string | null) {
        this._search = value;
    }

    /**
     * Generates and returns a new Request object based on the current configuration.
     *
     * The request is constructed using parameters defined in the `_config` object.
     * Depending on the HTTP method specified in `_config.ajaxMethod`, the request URL and body
     * will be formatted accordingly.
     *
     * For `GET` requests, the URL is appended with query parameters generated by `generateURLSearchParams()`.
     * For `POST` requests, the request body is generated by `generateRequestBody()` and stringifies as JSON.
     *
     * @private
     * @returns {Request}
     */
    private generateRequest(): Request {
        const ajaxURL = this._config.ajaxMethod === "GET" ? this._config.ajaxURL + "?" + this.generateURLSearchParams() : this._config.ajaxURL;
        const ajaxBody = this._config.ajaxMethod === "POST" ? JSON.stringify(this.generateRequestBody()) : null;

        return new Request(ajaxURL, {
            method: this._config.ajaxMethod,
            headers: this._config.ajaxHeaders,
            body: ajaxBody,
        });
    }

    /**
     * Generates and returns the request body containing pagination and sort data.
     *
     * @private
     */
    private generateRequestBody(): {
        search?: string,
        pagination?: { page: number, size: number },
        sort?: { column: string, direction: string }
    } {
        let requestBody: {
            search?: string,
            pagination?: { page: number, size: number },
            sort?: { column: string, direction: string }
        } = {};

        if (this._search !== null) {
            requestBody = { ...requestBody, search: this._search };
        }

        if (this._pagination !== null) {
            requestBody = {
                ...requestBody,
                pagination: { page: this._pagination.page, size: this._pagination.pageSize }
            };
        }

        if (this._sort !== null) {
            requestBody = {
                ...requestBody,
                sort: { column: this._sort.columnName, direction: this._sort.direction }
            };
        }

        return requestBody;
    }

    /**
     * Generates and returns URL search parameters based on the current pagination and sort settings.
     *
     * If pagination details are available, they are added as "pagination-page" and "pagination-size" parameters.
     * If sorting details are specified, they are added as "sort-column" and "sort-direction" parameters.
     *
     * @return {URLSearchParams}
     */
    private generateURLSearchParams(): URLSearchParams {
        let params = new URLSearchParams();

        if (this._search !== null) {
            params.append("search", this._search);
        }

        if (this._pagination !== null) {
            params.append("pagination[page]", this._pagination.page.toString());
            params.append("pagination[size]", this._pagination.pageSize.toString());
        }

        if (this._sort !== null) {
            params.append("sort[column]", this._sort.columnName);
            params.append("sort[direction]", this._sort.direction);
        }

        return params;
    }
};
